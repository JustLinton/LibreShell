# Libre Shell

操作系统课程设计——自制shell

#### 本地构建

需要依赖libreadline。

以ubuntu 20.04LTS 为例（可能需要修改/lib/x86_64-linux-gnu/libreadline.so为自己操作系统下libreadline的so库的路径。）

```shell
gcc lsh.c -o lsh /lib/x86_64-linux-gnu/libreadline.so  -Ireadline -Itermcap
```



#### 实验要求

（1）执行用户输入的合法命令，允许命令携带参数，如ls -la；

（2）在命令执行期间，允许用户按下一个给定的组合键结束命令的执行；

（3）支持I/O重定向（>、<）与管道（|）；

（4）支持命令的后台运行；

（5）保存用户最近输入的30个命令，可利用上下方向键进行选择；

（6）若用户输入非法命令，或找不到命令要执行的文件等，给出错误提示；



#### 支持管道、输入输出重定向机制

输入重定向：
（1）命令 < 文件：将文件作为命令的标准输入
（2）命令 << 分界符：从标准输入中读入，直到遇到分界符停止  //未实现
输出重定向：
（1）命令 > 文件：将标准输出重定向到文件中（清除原有文件中的数据）
（2）命令 2> 文件：将错误输出重定向到文件中（清除原有文件中的数据）
（3）命令 >> 文件：将标准输出重定向到文件中（在原有的内容后追加）
（4）命令 2>> 文件：将错误输出重定向到文件中（在原有内容后面追加）
（5）命令 >> 文件 2>&1，或  命令 &>> 文件：标准输出和错误输出共同写入文件（在原有内容后追加） //未完全实现
这些重定向命令可组合使用，如：
命令 < 文件1 >文件2：将文件1作为命令的标准输入并将标准输出到文件2
例如，在shell界面中输入命令 echo hello，你会看到在标准输出中打印了 hello 这个单词；如果你输入命令 echo hello > file.txt ，你会发现标准输出中并没有打印 hello 这个词，反而在当前目录下出现了一个名为 file.txt 的文件，这个文件中存储了一个单词 hello。
在命令echo hello > file.txt中，echo 是一个可执行文件，你可以在路径 /bin 下找到它。当 Shell 执行这个命令的时候会创建一个子进程来运行这个可执行文件，hello 是echo 的一个参数。
命令符 ">" 是标准输出的重定向符，它会将 echo 的输出重定向到文件 file.txt 中，而不是 stdout，相反，命令符 "<" 则是标准输入的重定向符，它会将输出重定向到文件中，而不是 stdin。两者可以结合。